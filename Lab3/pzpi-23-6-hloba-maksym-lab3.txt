МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
до лабораторного роботи №3 
з дисципліни «Аналіз та рефакторинг коду» на тему: 
«РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ»


Виконав:						Перевірив:
ст. гр. ПЗПІ-23-6				ас. катедри ПІ
Глоба Максим					Дашенков Дмитро Сергійович









Харків 2025
1 ЗАВДАННЯ
     Метою лабораторної роботи є набуття практичних навичок проєктування та програмної реалізації бізнес-логіки та функцій адміністрування серверної частини програмної системи. У ході виконання роботи студент повинен розробити та імплементувати алгоритми бізнес-логіки, що включають математичні методи обробки даних, а також реалізувати функціонал для адміністрування системи. Для візуалізації алгоритмів та процесів взаємодії компонентів необхідно створити UML-діаграму діяльності та UML-діаграму взаємодії для серверної частини.
     Важливим етапом є перевірка працездатності розробленої системи, під час якої студент має протестувати коректність виконання бізнес-логіки та надійність функцій адміністрування. Після завершення розробки програмний код необхідно завантажити або оновити у відповідному GitHub-репозиторії у гілці main.
     Результати роботи оформлюються у вигляді звіту, який повинен містити текстовий опис інженерних рішень, графічні ілюстрації у вигляді діаграм діяльності та взаємодії, а також фрагменти програмного коду, що демонструють реалізацію бізнес-логіки та функцій адміністрування. Звіт експортується у формат PDF для завантаження на платформу dl.nure.ua, а також у текстовий файл з кодуванням UTF-8 для розміщення в репозиторії лабораторних робіт.


     2 ОПИС ВИКОНАНОЇ РОБОТИ
     2.1 Текстовий опис інженерних рішень
     Програмний комплекс розроблено на базі платформи Node.js з використанням фреймворку NestJS. Вибір цього технологічного стеку обумовлений його модульною архітектурою, підтримкою патерну Dependency Injection та використанням мови TypeScript, що забезпечує сувору типізацію та знижує кількість помилок на етапі розробки.
     Архітектура системи та контейнеризація Розгортання системи реалізовано з використанням технології контейнеризації Docker. В файлі конфігурації docker-compose визначено три основні сервіси, що забезпечують роботу системи:
- Backend (NestJS API): основний сервер застосунку.
- PostgreSQL (v15): реляційна база даних для надійного зберігання інформації.
- EMQX (v5.5.0): високопродуктивний MQTT-брокер для обслуговування IoT-пристроїв. Такий підхід забезпечує ізоляцію середовищ виконання та спрощує масштабування компонентів незалежно один від одного.
     Збереження даних та ORM Взаємодія з базою даних PostgreSQL реалізована через ORM-бібліотеку TypeORM. Це дозволяє працювати з записами БД як з об'єктами класів (Entities).
- Для керування змінами структури БД використовується механізм міграцій (migrations), що дозволяє версіонувати схему даних.
- Збереження просторових даних (зон приміщень) реалізовано у спрощеній Декартовій системі координат (зберігання полів x_coordinate, y_coordinate, width, height), що є достатнім для відображення планів поверхів на клієнтській частині без залучення важких гео-інформаційних розширень (на кшталт PostGIS).
     Взаємодія з обладнанням (IoT та MQTT) Комунікація зі зчитувачами карток (RFID-рідери) побудована на протоколі MQTT. У якості брокера повідомлень обрано рішення EMQX.
- Схема підписки: Бекенд виступає як MQTT-клієнт (бібліотека mqtt), який підписується на wildcard-топік (шаблон inzone/readers/+/scan), що дозволяє отримувати події від усіх зареєстрованих рідерів одночасно.
- Безпека підключень: Реалізовано делеговану аутентифікацію. Брокер EMQX налаштований таким чином (через змінні оточення EMQX_AUTHENTICATION__...__URL), що при спробі підключення пристрою він виконує HTTP-запит до бекенду (/mqtt/auth). Це дозволяє централізовано керувати доступами пристроїв у базі даних самого застосунку, не редагуючи конфіги брокера.
     Режим реального часу (WebSocket) Для миттєвого відображення переміщень персоналу та сповіщень адміністратора використано бібліотеку Socket.io.
- Реалізовано поділ на простори імен (/locations та /notifications) для розмежування логіки.
- Використовується механізм "кімнат" (Rooms): клієнт підписується на кімнату конкретної будівлі (наприклад, building-12). Це оптимізує трафік, оскільки події про переміщення співробітника відправляються лише тим адміністраторам, які переглядають карту відповідної будівлі, а не всім підключеним клієнтам.
- Аутентифікація WebSocket-з'єднань здійснюється шляхом передачі та валідації JWT-токена на етапі рукостискання (handshake).
     Безпека Захист API реалізовано за допомогою стратегії Passport-JWT. Паролі користувачів та ключі доступу до MQTT хешуються з використанням алгоритму bcrypt. Система прав доступу базується на ролях (UserRole), контроль яких забезпечується через спеціальні Guards на рівні контролерів NestJS.
     2.2 Програмна реалізація бізнес-логіки та функцій адміністрування
     2.2.1 Бізнес-логіка (математичні методи обробки даних) серверної частини
     У цьому розділі наведено реалізацію алгоритмів обробки даних. Метод getCurrentEmployeeLocations демонструє логіку відстеження переміщення персоналу: він аналізує послідовність подій сканування RFID-міток, зіставляє їх з рідерами та дверима, і на основі історії переходів ("вхід/вихід") визначає поточну зону перебування кожного працівника. Також наведено метод createDoorsForTransitionZones, який використовує геометричні розрахунки перетинів для автоматичного створення зв'язків (дверей) між зонами при додаванні нового поверху.
     
      private async createDoorsForTransitionZones(
        buildingId: number,
        newFloor: Floor,
        manager: EntityManager,
      ): Promise<void> {
        const transitionZones = await this.zoneRepository.find({
          where: {
            building: { building_id: buildingId },
            is_transition_between_floors: true,
          },
        });
      
        for (let i = 0; i < transitionZones.length; i++) {
          for (let j = i + 1; j < transitionZones.length; j++) {
            const zone1 = transitionZones[i];
            const zone2 = transitionZones[j];
      
            const intersection = this.zoneGeometryValidator.calculateIntersection(
              this.createRectangleFromZone(zone1),
              this.createRectangleFromZone(zone2),
            );
      
            if (
              intersection.hasIntersection &&
              intersection.intersectionLength >=
                BUILDINGS_CONSTANTS.ZONE.MIN_INTERSECTION
            ) {
              const door = manager.create(Door, {
                zone_from: zone1,
                zone_to: zone2,
                is_entrance: false,
                entrance_door_side: null,
                floor: newFloor,
              });
      
              await manager.save(door);
            }
          }
        }
      }
     2.3.2 Адміністрування серверної частини
     У цьому розділі представлено реалізацію функцій адміністратора. Метод assignTagToEmployee забезпечує процес видачі фізичних перепусток (RFID) співробітникам. Він містить комплексну перевірку прав доступу, приналежності до організації та уникнення конфліктів (дублювання міток). Метод createBuilding демонструє використання транзакцій БД для гарантування цілісності даних при створенні складної ієрархічної структури (будівля -> поверх -> зона -> вхідні двері) за один запит.
     
      async assignTagToEmployee(
        tagAdminId: number,
        assignTagDto: AssignTagToEmployeeDto,
      ): Promise<void> {
        const tagAdmin = await this.tagAdminRepository.findOne({
          where: { tag_admin_id: tagAdminId },
          relations: ['organization'],
        });
      
        if (!tagAdmin || !tagAdmin.organization) {
          throw new NotFoundException(
            TAG_ADMIN_CONSTANTS.ERROR_MESSAGES.TAG_ADMIN_NOT_FOUND,
          );
        }
      
        const organizationId = tagAdmin.organization.organization_id;
      
        const employeeOrgCheck = await this.dataSource
          .createQueryBuilder()
          .select('1', 'exists')
          .from('employee_organizations_organization', 'emp_org')
          .where('emp_org.employeeEmployeeId = :employeeId', {
            employeeId: assignTagDto.employee_id,
          })
          .andWhere('emp_org.organizationOrganizationId = :organizationId', {
            organizationId,
          })
          .getRawOne<{ exists: string }>();
      
        if (!employeeOrgCheck) {
          throw new BadRequestException(
            TAG_ADMIN_CONSTANTS.ERROR_MESSAGES.EMPLOYEE_NOT_IN_TAG_ADMIN_ORGANIZATION,
          );
        }
      
        const employee = await this.employeeRepository.findOne({
          where: { employee_id: assignTagDto.employee_id },
          relations: ['positions'],
        });
      
        if (!employee) {
          throw new NotFoundException(
            TAG_ADMIN_CONSTANTS.ERROR_MESSAGES.EMPLOYEE_NOT_FOUND,
          );
        }
      
        if (!employee.positions || employee.positions.length === 0) {
          throw new BadRequestException(
            TAG_ADMIN_CONSTANTS.ERROR_MESSAGES.EMPLOYEE_HAS_NO_POSITION,
          );
        }
      
        const rfidTag = await this.rfidTagRepository.findOne({
          where: { rfid_tag_id: assignTagDto.rfid_tag_id },
          relations: ['organization'],
        });
      
        if (!rfidTag) {
          throw new NotFoundException(
            TAG_ADMIN_CONSTANTS.ERROR_MESSAGES.RFID_TAG_NOT_FOUND,
          );
        }
      
        if (rfidTag.organization.organization_id !== organizationId) {
          throw new BadRequestException(
            TAG_ADMIN_CONSTANTS.ERROR_MESSAGES.TAG_ORGANIZATION_MISMATCH,
          );
        }
      
        const existingTagAssignment = await this.tagAssignmentRepository
          .createQueryBuilder('ta')
          .where('ta.rfid_tag_id = :rfidTagId', {
            rfidTagId: assignTagDto.rfid_tag_id,
          })
          .leftJoinAndSelect('ta.employee', 'employee')
          .getOne();
      
        if (existingTagAssignment) {
          if (
            existingTagAssignment.employee?.employee_id === assignTagDto.employee_id
          ) {
            throw new ConflictException(
              TAG_ADMIN_CONSTANTS.ERROR_MESSAGES.EMPLOYEE_ALREADY_HAS_THIS_TAG,
            );
          }
          throw new ConflictException(
            TAG_ADMIN_CONSTANTS.ERROR_MESSAGES.TAG_ALREADY_ASSIGNED,
          );
        }
      
        const employeeHasTagInOrg = await this.tagAssignmentRepository
          .createQueryBuilder('ta')
          .innerJoin('ta.rfid_tag', 'rfid_tag')
          .where('ta.employee_id = :employeeId', {
            employeeId: assignTagDto.employee_id,
          })
          .andWhere('rfid_tag.organization_id = :organizationId', {
            organizationId,
          })
          .getOne();
      
        if (employeeHasTagInOrg) {
          throw new ConflictException(
            TAG_ADMIN_CONSTANTS.ERROR_MESSAGES.EMPLOYEE_ALREADY_HAS_TAG_IN_ORGANIZATION,
          );
        }
      
        const newAssignment = this.tagAssignmentRepository.create({
          employee: { employee_id: assignTagDto.employee_id },
          rfid_tag: { rfid_tag_id: assignTagDto.rfid_tag_id },
          tag_admin: { tag_admin_id: tagAdminId },
          tag_assignment_change_date_and_time: new Date(),
        });
      
        await this.tagAssignmentRepository.save(newAssignment);
      }
      
      async createBuilding(userId: number, createBuildingDto: CreateBuildingDto) {
        await this.organizationOwnershipValidator.validateOwnership(
          userId,
          createBuildingDto.organization_id,
        );
      
        return this.dataSource.transaction(async (manager) => {
          const building = await this.createBuildingEntity(
            createBuildingDto,
            manager,
          );
          const firstFloor = await this.createFloorEntity(building, manager);
          const firstZone = await this.createZoneEntity(
            firstFloor,
            building,
            manager,
          );
          const entranceDoor = await this.createEntranceDoorEntity(
            firstZone,
            firstFloor,
            manager,
          );
      
          return {
            building,
            floor: firstFloor,
            zone: firstZone,
            door: entranceDoor,
          };
        });
      }
     2.3 Графічні ілюстрації
     2.3.1 UML діаграма діяльності для алгоритму обробки запиту доступу від зчитувача
     Ця діаграма відображає послідовність дій серверної частини при отриманні даних від RFID-зчитувача. Після ідентифікації мітки та рідера система визначає напрямок руху та цільову зону. Ключовим етапом є аналіз прав доступу: завантажуються правила зони для посад співробітника та перевіряється, чи є у нього хоча б одна посада, яка не має заборони на вхід. Залежно від результату перевірки (так/ні), система або оновлює поточну зону співробітника і створює успішний запис події (Scan Event), або фіксує спробу порушення доступу. Завершується процес створенням відповідних сповіщень про переміщення.
 
Рисунок 2.1 – UML діаграма діяльності для алгоритму обробки запиту доступу від зчитувача
     2.3.2 UML діаграма діяльності для алгоритму фонового моніторингу часових лімітів
     Діаграма описує логіку роботи планувальника завдань (Scheduler), який запускається щохвилини. Система завантажує список усіх співробітників, що перебувають у будівлі, і для кожного перевіряє наявність правил обмеження часу (TimeLimited) у їхній поточній зоні. Алгоритм розраховує час перебування (різниця між поточним часом та часом останнього сканування) і порівнює його з лімітом. Якщо ліміт перевищено, виконується перевірка на "анти-спам" (чи вже було надіслано сповіщення). У разі первинного порушення створюється сповіщення про перевищення часу, яке надсилається співробітнику, а час останнього сповіщення оновлюється.
 
Рисунок 2.2 – UML діаграма діяльності для алгоритму фонового моніторингу часових лімітів
     2.3.3 UML діаграма діяльності для алгоритму автоматичної генерації та ручного редагування топології будівлі
     Діаграма діяльності ілюструє логіку роботи адміністратора при створенні структури будівлі. Процес починається з автогенерації базових сутностей (перший поверх, початкова зона 10x10 та вхідні двері). Далі система пропонує вибір дій: додавання вхідних дверей, додавання дверей між зонами або створення нової зони. Для кожної дії реалізовано алгоритм геометричної валідації: розраховуються вільні сегменти стін, перевіряється довжина перетину між зонами та наявність колізій (накладання) нових зон на існуючі. У випадку виявлення помилок (наприклад, відсутність місця для дверей або накладання зон) процес завершується відповідним повідомленням, інакше — зміни зберігаються в базі даних.

Рисунок 2.3 – UML діаграма діяльності для алгоритму автоматичної генерації та ручного редагування топології будівлі
      2.3.4 UML діаграма взаємодії для обробки події доступу в реальному часі
     На цій діаграмі показано обмін повідомленнями між компонентами системи під час проходу співробітника. Зчитувач надсилає ідентифікатори (TagID, ReaderID) на серверну частину (Backend), яка проводить валідацію даних. Якщо доступ дозволено (штатний режим), система зберігає подію, оновлює зону співробітника та транслює оновлення на карту в реальному часі для адміністратора. Якщо виявлено порушення правил, фіксується подія порушення. При порушенні співробітник отримує PUSH-сповіщення про нього, а система завершує транзакцію.

Рисунок 2.4 – UML діаграма взаємодії для обробки події доступу в реальному часі
     2.3.5 UML діаграма взаємодії для періодичної перевірки лімітів перебування (Scheduler Loop)
     Діаграма ілюструє взаємодію фонового сервісу (Scheduler) з базою даних та клієнтськими додатками. Тригер (Cron) ініціює процес збору даних, після чого система отримує список активних сесій співробітників. Далі в циклі для кожного користувача відбувається перевірка ліміту часу (TimeLimited). Якщо розрахований час перебування перевищує норму, система перевіряє інтервал останнього сповіщення (Anti-Spam). При підтвердженні необхідності сповіщення, Backend паралельно надсилає повідомлення адміністратору (для відображення в веб-інтерфейсі) та PUSH-повідомлення співробітнику в мобільний додаток.

Рисунок 2.5 – UML діаграма взаємодії для періодичної перевірки лімітів перебування (Scheduler Loop)
     2.3.6 UML діаграма взаємодії для процесу реєстрації співробітника та прив'язки RFID-мітки
     Діаграма послідовності деталізує взаємодію між адміністраторами, співробітником та системою під час налаштування профілю. Процес поділено на дві фази. У першій фазі адміністратор організації створює посаду та надсилає запрошення, а співробітник через мобільний додаток надає юридичну згоду на моніторинг. Друга фаза — це прив'язка мітки, яку виконує Tag Admin. Система перевіряє наявність посади у співробітника, переходить у режим очікування, отримує ID мітки від фізичного зчитувача та, за умови успішної валідації унікальності, зберігає прив'язку в базі даних.

Рисунок 2.6 – UML діаграма взаємодії для процесу реєстрації співробітника та прив'язки RFID-мітки

3 ВИСНОВКИ
     У ході виконання лабораторної роботи було спроєктовано та програмно реалізовано складну бізнес-логіку та адміністративні функції серверної частини системи контролю доступу InZone. Основний акцент було зроблено на розробці алгоритмів обробки даних, забезпеченні цілісності транзакцій та автоматизації процесів управління доступом.
     Було опрацьовано та впроваджено математичні методи для роботи з просторовими даними, зокрема реалізовано валідацію геометрії зон, розрахунок перетинів прямокутників та автоматичну генерацію зв'язків (дверей) між приміщеннями. Це дозволило створити гнучкий механізм моделювання топології будівель, що автоматично запобігає колізіям та логічним помилкам при створенні карти об'єкта. Крім того, було реалізовано алгоритм відстеження переміщення персоналу в реальному часі, який базується на аналізі історії подій сканування RFID-міток та стані контрольних точок.
     Особливу увагу приділено функціям адміністрування та безпеки даних. Засобами фреймворку NestJS та TypeORM реалізовано транзакційні механізми для атомарного виконання складних операцій, таких як одночасне створення повної ієрархії об'єкта нерухомості (будівля-поверх-зона). Також розроблено захищену логіку прив'язки фізичних ідентифікаторів (RFID-тегів) до профілів співробітників із багаторівневою перевіркою прав доступу та приналежності до організації. Для забезпечення контролю часових лімітів було налаштовано роботу фонових завдань (Scheduler), які періодично аналізують тривалість перебування працівників у зонах та генерують відповідні сповіщення.
     Для візуалізації та документування розроблених процесів було створено UML-діаграми діяльності та взаємодії. Це дозволило детально відобразити алгоритми прийняття рішень системою, зокрема логіку надання доступу та обробку порушень, а також проілюструвати динаміку обміну повідомленнями між сервером, базою даних та клієнтськими застосунками. Таким чином, у результаті роботи було сформовано навички проєктування та імплементації насиченої бізнес-логіки, що виходить за межі стандартних CRUD-операцій і забезпечує інтелектуальну поведінку програмної системи.
		 2



