МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
до лабораторного роботи №4 
з дисципліни «Аналіз та рефакторинг коду» на тему: 
«РОЗРОБКА IoT КЛІЄНТА  (БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)»


Виконав:						Перевірив:
ст. гр. ПЗПІ-23-6				ас. катедри ПІ
Глоба Максим					Дашенков Дмитро Сергійович









Харків 2025
1 ЗАВДАННЯ
     Метою лабораторної роботи є набуття практичних навичок проєктування та програмної реалізації клієнтської частини системи Інтернету речей (IoT). У ході виконання роботи студент повинен розробити архітектуру програмного забезпечення для IoT-пристрою, імплементувати алгоритми бізнес-логіки, що включають математичну обробку даних предметної області, а також реалізувати функції налаштування (конфігурації) клієнта.
     Для візуалізації вимог до системи та логіки процесів необхідно створити UML-діаграму прецедентів та UML-діаграму діяльності для IoT-клієнта.
     Важливим етапом є перевірка працездатності розробленого пристрою, під час якої студент має протестувати коректність виконання математичних операцій бізнес-логіки та надійність механізмів налаштування параметрів. Після завершення розробки та тестування програмний код необхідно завантажити або оновити у відповідному GitHub-репозиторії у гілці main.
     Результати роботи оформлюються у вигляді звіту, який повинен містити текстовий опис інженерних рішень, графічні ілюстрації (UML-діаграми), а також фрагменти програмного коду, що демонструють реалізацію бізнес-логіки та функцій налаштування. Звіт експортується у формат PDF для завантаження на платформу dl.nure.ua, а також у текстовий файл з кодуванням UTF-8 для розміщення в репозиторії лабораторних робіт.


     2 ОПИС ВИКОНАНОЇ РОБОТИ
     2.1 Текстовий опис інженерних рішень
     Програмний комплекс розроблено на базі платформи Node.js з використанням фреймворку NestJS. Вибір цього технологічного стеку обумовлений його модульною архітектурою, підтримкою патерну Dependency Injection та використанням мови TypeScript, що забезпечує сувору типізацію та знижує кількість помилок на етапі розробки.
     Архітектура системи та контейнеризація Розгортання системи реалізовано з використанням технології контейнеризації Docker. В файлі конфігурації docker-compose визначено три основні сервіси, що забезпечують роботу системи:
- Backend (NestJS API): основний сервер застосунку.
- PostgreSQL (v15): реляційна база даних для надійного зберігання інформації.
- EMQX (v5.5.0): високопродуктивний MQTT-брокер для обслуговування IoT-пристроїв. Такий підхід забезпечує ізоляцію середовищ виконання та спрощує масштабування компонентів незалежно один від одного.
     Збереження даних та ORM Взаємодія з базою даних PostgreSQL реалізована через ORM-бібліотеку TypeORM. Це дозволяє працювати з записами БД як з об'єктами класів (Entities).
- Для керування змінами структури БД використовується механізм міграцій (migrations), що дозволяє версіонувати схему даних.
- Збереження просторових даних (зон приміщень) реалізовано у спрощеній Декартовій системі координат (зберігання полів x_coordinate, y_coordinate, width, height), що є достатнім для відображення планів поверхів на клієнтській частині без залучення важких гео-інформаційних розширень (на кшталт PostGIS).
     Взаємодія з обладнанням (IoT та MQTT) Комунікація зі зчитувачами карток (RFID-рідери) побудована на протоколі MQTT. У якості брокера повідомлень обрано рішення EMQX.
- Схема підписки: Бекенд виступає як MQTT-клієнт (бібліотека mqtt), який підписується на wildcard-топік (шаблон inzone/readers/+/scan), що дозволяє отримувати події від усіх зареєстрованих рідерів одночасно.
- Безпека підключень: Реалізовано делеговану аутентифікацію. Брокер EMQX налаштований таким чином (через змінні оточення EMQX_AUTHENTICATION__...__URL), що при спробі підключення пристрою він виконує HTTP-запит до бекенду (/mqtt/auth). Це дозволяє централізовано керувати доступами пристроїв у базі даних самого застосунку, не редагуючи конфіги брокера.
     Режим реального часу (WebSocket) Для миттєвого відображення переміщень персоналу та сповіщень адміністратора використано бібліотеку Socket.io.
- Реалізовано поділ на простори імен (/locations та /notifications) для розмежування логіки.
- Використовується механізм "кімнат" (Rooms): клієнт підписується на кімнату конкретної будівлі (наприклад, building-12). Це оптимізує трафік, оскільки події про переміщення співробітника відправляються лише тим адміністраторам, які переглядають карту відповідної будівлі, а не всім підключеним клієнтам.
- Аутентифікація WebSocket-з'єднань здійснюється шляхом передачі та валідації JWT-токена на етапі рукостискання (handshake).
     Безпека Захист API реалізовано за допомогою стратегії Passport-JWT. Паролі користувачів та ключі доступу до MQTT хешуються з використанням алгоритму bcrypt. Система прав доступу базується на ролях (UserRole), контроль яких забезпечується через спеціальні Guards на рівні контролерів NestJS.
     Реалізація IoT клієнта (Embedded System) Клієнтську частину системи реалізовано на апаратній платформі ESP32. Програмне забезпечення написано мовою C++ (Arduino Framework). Клієнт відповідає за безпосередню взаємодію з фізичними датчиками (RFID-зчитувачами) та передачу даних на сервер.
- Функції налаштування: Для забезпечення гнучкості конфігурації використано бібліотеку WiFiManager. Пристрій підтримує режим точки доступу (AP) з Web-порталом, що дозволяє користувачеві налаштувати параметри підключення до Wi-Fi мережі, адресу MQTT-брокера, а також унікальні ідентифікатори та токени безпеки зчитувачів без зміни прошивки. Дані зберігаються в енергонезалежній пам'яті (NVS/Preferences).
- Бізнес-логіка клієнта: Реалізовано паралельне опитування двох UART-портів (HardwareSerial) для отримання даних з підключених RFID-модулів. Програма виконує фільтрацію вхідного байтового потоку (видалення службових символів протоколу зчитувача), формує JSON-пакет відповідно до визначеного API та відправляє його у відповідний MQTT-топік. Також реалізовано програмний захист від "брязкоту" контактів (debouncing), що запобігає дублюванню транзакцій.
     2.2 Фрагменти програмного коду
     2.2.1 Бізнес-логіка IoT клієнта (обробка даних та відправка)
     Реалізовано функцію processReader, яка відповідає за зчитування байтового потоку з RFID-рідера, фільтрацію службових байтів (STX, ETX), перевірку часового інтервалу (математична логіка затримки) та публікацію JSON-пакету в MQTT топік.
     
      void processReader(HardwareSerial& serialPort, PubSubClient& mqttClient, const char* rId, const char* rToken, unsigned long& lastRead) {
        ensureConnection(mqttClient, rId, rToken);
        mqttClient.loop();
      
        if (serialPort.available()) {
          String tagID = "";
          while (serialPort.available()) {
            uint8_t byteIn = serialPort.read();
            if (byteIn != 0x02 && byteIn != 0x03 && byteIn != 0x0A && byteIn != 0x0D) {
              tagID += (char)byteIn;
            }
            delay(2);
          }
      
          if (tagID.length() > 0 && (millis() - lastRead > READ_DELAY)) {
            Serial.printf("[Reader %s] SCAN: %s\n", rId, tagID.c_str());
      
            if (mqttClient.connected()) {
              String topic = "inzone/readers/" + String(rId) + "/scan";
              String payload = "{\"tag_uid\": \"" + tagID + "\"}";
      
              mqttClient.publish(topic.c_str(), payload.c_str());
            } else {
              Serial.println("[ERROR] Немає MQTT з'єднання, дані втрачено.");
            }
            lastRead = millis();
          }
        }
      }
     2.2.2 Налаштування IoT клієнта
     У цьому фрагменті продемонстровано використання WiFiManager для створення полів налаштувань та збереження параметрів (IP сервера, токени авторизації) у пам'ять пристрою через бібліотеку Preferences.
     
      void setup() {
        Serial.begin(115200);
        pinMode(RESET_PIN, INPUT_PULLUP);
        pinMode(LED_PIN, OUTPUT);
        delay(1000);
      
        Serial.println("\n\n=== ЗАПУСК СИСТЕМИ (FIXED) ===");
      
        if (digitalRead(RESET_PIN) == LOW) {
          Serial.println("Кнопка затиснута! Скидання...");
          delay(2000);
          performFactoryReset();
        }
      
        loadConfig();
      
        WiFiManagerParameter custom_mqtt_server("server", "MQTT Server IP", mqtt_server, 64);
        WiFiManagerParameter custom_mqtt_port("port", "MQTT Port", mqtt_port, 6);
        WiFiManagerParameter custom_r1_id("r1id", "Reader 1 ID", reader1_id, 16);
        WiFiManagerParameter custom_r1_token("r1tok", "Reader 1 Token", reader1_token, 128);
        WiFiManagerParameter custom_r2_id("r2id", "Reader 2 ID", reader2_id, 16);
        WiFiManagerParameter custom_r2_token("r2tok", "Reader 2 Token", reader2_token, 128);
      
        wm.addParameter(&custom_mqtt_server);
        wm.addParameter(&custom_mqtt_port);
        wm.addParameter(&custom_r1_id);
        wm.addParameter(&custom_r1_token);
        wm.addParameter(&custom_r2_id);
        wm.addParameter(&custom_r2_token);
      
        wm.setSaveParamsCallback(saveConfigCallback);
        wm.setConfigPortalTimeout(180);
      
        if (!wm.autoConnect("InZone_Config", "password123")) {
          Serial.println("Failed to connect WiFi. Restarting...");
          delay(3000);
          ESP.restart();
        }
      
        Serial.println("[WiFi] Підключено!");
        Serial.print("[WiFi] IP: ");
        Serial.println(WiFi.localIP());
      
        if (strlen(custom_mqtt_server.getValue()) > 0) strcpy(mqtt_server, custom_mqtt_server.getValue());
        if (strlen(custom_mqtt_port.getValue()) > 0)    strcpy(mqtt_port, custom_mqtt_port.getValue());
      
        if (strlen(custom_r1_id.getValue()) > 0)        strcpy(reader1_id, custom_r1_id.getValue());
        if (strlen(custom_r1_token.getValue()) > 0)     strcpy(reader1_token, custom_r1_token.getValue());
      
        if (strlen(custom_r2_id.getValue()) > 0)        strcpy(reader2_id, custom_r2_id.getValue());
        if (strlen(custom_r2_token.getValue()) > 0)     strcpy(reader2_token, custom_r2_token.getValue());
      
        saveConfigCallback();
      
        SerialReader1.begin(9600, SERIAL_8N1, RX_PIN_1, TX_DUMMY);
        SerialReader2.begin(9600, SERIAL_8N1, RX_PIN_2, TX_DUMMY);
      
        int port = atoi(mqtt_port);
        mqttClient1.setServer(mqtt_server, port);
        mqttClient2.setServer(mqtt_server, port);
        mqttClient1.setSocketTimeout(5);
        mqttClient2.setSocketTimeout(5);
      }
      
      void saveConfigCallback() {
        Serial.println("[INFO] Збереження налаштувань у флеш...");
        preferences.begin("inzone", false);
        preferences.putString("mqtt_server", mqtt_server);
        preferences.putString("mqtt_port", mqtt_port);
        preferences.putString("r1_id", reader1_id);
        preferences.putString("r1_token", reader1_token);
        preferences.putString("r2_id", reader2_id);
        preferences.putString("r2_token", reader2_token);
        preferences.end();
      }
     2.3 Графічні ілюстрації
     2.3.1 UML діаграма прецедентів ІоТ клієнта
     Представлено діаграму прецедентів, яка окреслює межі системи та рольову модель взаємодії. Діаграма визначає трьох основних акторів: Адміністратора організації, Співробітника та апаратний RFID-зчитувач. Адміністратор виступає як актор, що має права на конфігурацію параметрів мережі та MQTT-брокера, а також на повне скидання налаштувань до заводських (Factory Reset). Співробітник є ініціатором основного бізнес-процесу, використовуючи фізичну картку доступу.
     Функціонал системи включає кілька ключових прецедентів. Процес сканування мітки (Scan RFID tag) запускає ланцюжок внутрішніх дій, таких як обробка та фільтрація сирих даних (Process and filter data), а також подальша публікація події (Publish scan event). Важливим аспектом є те, що публікація даних включає в себе обов'язковий етап аутентифікації пристрою на сервері, що забезпечує безпеку передачі інформації.
 
Рисунок 2.1 – UML діаграма прецедентів IoT клієнта
     2.3.2 UML діаграма діяльності ІоТ клієнта
     Наведено діаграму діяльності, яка детально описує алгоритм роботи прошивки ESP32. Процес розпочинається з ініціалізації апаратних інтерфейсів (Serial-портів та GPIO) і перевірки стану фізичної кнопки Reset. Якщо кнопка утримується понад 5 секунд, система виконує очищення пам'яті (Preferences) та перезавантажується. У штатному режимі відбувається спроба завантаження конфігурації та підключення до мережі Wi-Fi. У разі невдачі запускається режим точки доступу (AP Mode) з веб-порталом для ручного введення налаштувань користувачем.
     Після успішного підключення до мережі та MQTT-брокера система переходить у нескінченний цикл обробки (Loop). Цей цикл включає постійну перевірку статусу з'єднання з можливістю автоматичного перепідключення, а також опитування послідовних портів RFID-рідерів. Отримані дані проходять етап фільтрації службових байтів та перевірку на валідність з урахуванням часової затримки (Debounce logic) для усунення дублювання. У разі успішного проходження всіх перевірок формується JSON-пакет, який публікується у відповідний MQTT-топік, після чого ітерація завершується.
 
Рисунок 2.2 – UML діаграма діяльності алгоритму роботи IoT клієнта

3 ВИСНОВКИ
     У ході виконання лабораторної роботи було спроєктовано та програмно реалізовано клієнтську частину системи контролю доступу InZone на базі вбудованої системи (Embedded System) з використанням мікроконтролера ESP32. Основний акцент було зроблено на забезпеченні стабільної взаємодії апаратного забезпечення з хмарною інфраструктурою, реалізації надійних протоколів передачі даних та створенні гнучких механізмів налаштування пристрою.
     Було опрацьовано та впроваджено алгоритми первинної обробки даних на стороні клієнта («Edge Computing»). Зокрема, реалізовано логіку зчитування байтових потоків з RFID-модулів через інтерфейси UART, фільтрацію службових символів протоколу та валідацію отриманих ідентифікаторів. Для підвищення надійності системи розроблено математичний алгоритм усунення «брязкоту» (debouncing), який запобігає дублюванню транзакцій та надлишковому навантаженню на мережу при тривалому утриманні картки в полі дії зчитувача. Комунікацію з сервером організовано через протокол MQTT, що забезпечує низьку затримку та гарантовану доставку повідомлень у форматі JSON.
     Особливу увагу приділено функціям адміністрування та UX (User Experience) при налаштуванні IoT-пристрою. Відмовлено від практики жорсткого кодування (hardcoding) облікових даних у прошивці. Натомість інтегровано бібліотеку WiFiManager, що дозволило реалізувати режим точки доступу (Access Point) з веб-порталом для введення параметрів Wi-Fi мережі, адреси MQTT-брокера та токенів авторизації. Для збереження конфігурації між перезавантаженнями використано механізми роботи з енергонезалежною пам'яттю (NVS/Preferences), що робить пристрій автономним та зручним у розгортанні.
     Для візуалізації та документування архітектури клієнта було створено UML-діаграму прецедентів та діаграму діяльності. Це дозволило чітко окреслити сценарії використання пристрою різними акторами, а також деталізувати алгоритмічну структуру прошивки — від ініціалізації периферії до циклічної обробки подій. Таким чином, у результаті роботи було сформовано практичні навички розробки програмного забезпечення для вбудованих систем, роботи з апаратними інтерфейсами та реалізації сучасних IoT-протоколів.
     Посилання на GitHub для backend частини:
       https://github.com/InZoneProject/backend
     Посилання на GitHub для IOT частини:
       https://github.com/InZoneProject/iot-rfid-reader
		 2



