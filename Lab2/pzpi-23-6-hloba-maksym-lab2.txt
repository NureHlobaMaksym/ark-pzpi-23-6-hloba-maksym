МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
до лабораторного роботи №2 
з дисципліни «Аналіз та рефакторинг коду» на тему: 
«РОЗРОБКА БАЗИ ДАНИХ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ ТА ПРИКЛАДНОГО ПРОГРАМНОГО ІНТЕРФЕЙСУ (API)»


Виконав:						Перевірив:
ст. гр. ПЗПІ-23-6				ас. катедри ПІ
Глоба Максим					Дашенков Дмитро Сергійович









Харків 2025
1 ЗАВДАННЯ
     Метою лабораторної роботи є набуття практичних навичок проєктування та реалізації серверної частини програмної системи, зокрема розробки бази даних та прикладного програмного інтерфейсу (API).
     У ході виконання роботи студент повинен розробити архітектуру програмної системи та спроєктувати її серверну частину. Це включає створення UML-діаграми прецедентів для визначення функціоналу сервера, а також розробку логічної моделі даних у вигляді ER-діаграми, що відображає сутності, атрибути та зв’язки між ними.
     Окрім цього, студент має реалізувати фізичну базу даних та візуалізувати її структуру на діаграмі. Необхідно розробити програмний код для взаємодії з базою даних, використовуючи підходи ORM (Object-Relational Mapping) або CORM, а також реалізувати API (REST, GraphQL, gRPC тощо) для забезпечення обміну даними між сервером та клієнтськими частинами системи. Для розробленого API має бути створена відповідна специфікація.
     Важливим етапом є програмна реалізація всієї бізнес-логіки серверної частини та проведення перевірки її працездатності. Студент повинен протестувати взаємодію компонентів системи з базою даних та переконатися у коректності роботи API.
     Після завершення розробки програмний код необхідно завантажити або оновити у відповідному GitHub-репозиторії. Результати роботи оформлюються у вигляді звіту, який експортується у формат PDF для завантаження на платформу dl.nure.ua, а також у текстовий файл з кодуванням UTF-8 для розміщення в репозиторії лабораторних робіт.


     2 ОПИС ВИКОНАНОЇ РОБОТИ
     2.1 Текстовий опис інженерних рішень
     Програмний комплекс розроблено на базі платформи Node.js з використанням фреймворку NestJS. Вибір цього технологічного стеку обумовлений його модульною архітектурою, підтримкою патерну Dependency Injection та використанням мови TypeScript, що забезпечує сувору типізацію та знижує кількість помилок на етапі розробки.
     Архітектура системи та контейнеризація Розгортання системи реалізовано з використанням технології контейнеризації Docker. В файлі конфігурації docker-compose визначено три основні сервіси, що забезпечують роботу системи:
- Backend (NestJS API): основний сервер застосунку.
- PostgreSQL (v15): реляційна база даних для надійного зберігання інформації.
- EMQX (v5.5.0): високопродуктивний MQTT-брокер для обслуговування IoT-пристроїв. Такий підхід забезпечує ізоляцію середовищ виконання та спрощує масштабування компонентів незалежно один від одного.
     Збереження даних та ORM Взаємодія з базою даних PostgreSQL реалізована через ORM-бібліотеку TypeORM. Це дозволяє працювати з записами БД як з об'єктами класів (Entities).
- Для керування змінами структури БД використовується механізм міграцій (migrations), що дозволяє версіонувати схему даних.
- Збереження просторових даних (зон приміщень) реалізовано у спрощеній Декартовій системі координат (зберігання полів x_coordinate, y_coordinate, width, height), що є достатнім для відображення планів поверхів на клієнтській частині без залучення важких гео-інформаційних розширень (на кшталт PostGIS).
     Взаємодія з обладнанням (IoT та MQTT) Комунікація зі зчитувачами карток (RFID-рідери) побудована на протоколі MQTT. У якості брокера повідомлень обрано рішення EMQX.
- Схема підписки: Бекенд виступає як MQTT-клієнт (бібліотека mqtt), який підписується на wildcard-топік (шаблон inzone/readers/+/scan), що дозволяє отримувати події від усіх зареєстрованих рідерів одночасно.
- Безпека підключень: Реалізовано делеговану аутентифікацію. Брокер EMQX налаштований таким чином (через змінні оточення EMQX_AUTHENTICATION__...__URL), що при спробі підключення пристрою він виконує HTTP-запит до бекенду (/mqtt/auth). Це дозволяє централізовано керувати доступами пристроїв у базі даних самого застосунку, не редагуючи конфіги брокера.
     Режим реального часу (WebSocket) Для миттєвого відображення переміщень персоналу та сповіщень адміністратора використано бібліотеку Socket.io.
- Реалізовано поділ на простори імен (/locations та /notifications) для розмежування логіки.
- Використовується механізм "кімнат" (Rooms): клієнт підписується на кімнату конкретної будівлі (наприклад, building-12). Це оптимізує трафік, оскільки події про переміщення співробітника відправляються лише тим адміністраторам, які переглядають карту відповідної будівлі, а не всім підключеним клієнтам.
- Аутентифікація WebSocket-з'єднань здійснюється шляхом передачі та валідації JWT-токена на етапі рукостискання (handshake).
     Безпека Захист API реалізовано за допомогою стратегії Passport-JWT. Паролі користувачів та ключі доступу до MQTT хешуються з використанням алгоритму bcrypt. Система прав доступу базується на ролях (UserRole), контроль яких забезпечується через спеціальні Guards на рівні контролерів NestJS.
     2.2 Специфікація API для взаємодії серверної частини з клієнтами
     Взаємодія між клієнтським програмним забезпеченням та серверною частиною реалізована на основі архітектурного стилю REST (Representational State Transfer). Обмін інформацією здійснюється за протоколом HTTP з використанням формату JSON як основного стандарту серіалізації даних. Такий підхід забезпечує чітке розмежування між інтерфейсом користувача та бізнес-логікою, дозволяючи використовувати єдиний серверний API для різних платформ, включаючи веб-браузери та потенційні мобільні додатки. Кожен інформаційний об'єкт системи, такий як організація, співробітник або RFID-мітка, представлений окремим ресурсом з унікальною URL-адресою.
     Для забезпечення актуальності та зручності використання інтерфейсів прикладного програмування в проєкт інтегровано специфікацію OpenAPI 3.0. Генерація технічної документації відбувається автоматично на основі декораторів у коді контролерів завдяки бібліотеці Swagger. Це дозволяє розробникам клієнтської частини користуватися інтерактивним веб-інтерфейсом, який містить детальний опис усіх доступних ендпоінтів, необхідних параметрів запитів та структур відповідей. Інтерактивна документація також надає можливість тестувати виконання запитів у реальному часі безпосередньо з браузера.
     Безпека доступу до ресурсів API забезпечується використанням стандарту автентифікації Bearer Authentication з застосуванням JSON Web Token (JWT). Клієнтська частина зобов'язана додавати валідний токен доступу у заголовок Authorization кожного захищеного HTTP-запиту. На серверній стороні реалізовано механізм охоронців (Guards), які перехоплюють запити до виконання основної логіки, перевіряють валідність підпису токена та наявність у користувача відповідних прав доступу згідно з ролевою моделлю системи.
     Для гарантування цілісності та коректності даних на глобальному рівні застосунку впроваджено конвеєр валідації. Всі вхідні дані, що надходять у тілі запитів, автоматично перевіряються на відповідність суворим схемам об'єктів передачі даних (DTO). Система налаштована на автоматичне видалення будь-яких полів, що не описані у специфікації, що захищає базу даних від запису неконтрольованої інформації. Також реалізовано автоматичне перетворення типів даних, що спрощує обробку параметрів, отриманих через рядки URL-запитів.
     Архітектура API передбачає використання стандартизованих методів HTTP, де GET використовується для отримання даних, POST для створення нових записів, PATCH і PUT для оновлення та DELETE для видалення ресурсів. Для оптимізації роботи з великими обсягами інформації, наприклад списками організацій чи логами проходів, реалізовано уніфіковану пагінацію через параметри ліміту та зміщення. Крім того, API підтримує роботу зі специфічними форматами даних, зокрема multipart/form-data, що використовується для завантаження графічних файлів, таких як фотографії користувачів та зон.
     Реалізованні запити:

Рисунок 2.1 – Запити модуля авторизації


Рисунок 2.2 – Запити модуля глобального адміна


Рисунок 2.3 – Запити модуля організації

Рисунок 2.4 – Запити модуля співробітника


Рисунок 2.5 – Запити модуля будівлі


Рисунок 2.6 – Запити модуля RFID


Рисунок 2.7 – Запити модуля контролю доступу


Рисунок 2.8 – Запити модуля сповіщень


Рисунок 2.9 – Запити модуля тег адміна


Рисунок 2.10 – Запити модуля MQTT
     2.3 Програмна реалізація основних компонентів системи
     2.3.1 Логіка взаємодії серверної частини з клієнтами.
     Взаємодія серверної частини з клієнтськими застосунками реалізована на архітектурному рівні контролерів, які відповідають за прийом HTTP-запитів, первинну обробку вхідних даних та надсилання відповідей. Контролер визначає маршрути доступу до ресурсів API та використовує декоратори для прив’язки методів класу до відповідних HTTP-методів. У наведеному нижче лістингу продемонстровано реалізацію методу створення організації. Використання декоратора @Body забезпечує автоматичне вилучення даних з тіла запиту та їх перетворення у відповідний об’єкт, а декоратор @Roles обмежує доступ до ендпоінту, дозволяючи виконання операції лише користувачам із відповідними правами адміністратора.
     Метод контролера для обробки запиту створення організації:
     
      @ApiTags('Organizations')
      @Controller('organizations')
      @UseGuards(JwtAuthGuard, RolesGuard, EmailVerificationGuard)
      @ApiBearerAuth('JWT-auth')
      export class OrganizationsController {
        constructor(private readonly organizationsService: OrganizationsService) {}
      
        @Post()
        @Roles(UserRole.ORGANIZATION_ADMIN)
        async create(
          @Body() createOrganizationDto: OrganizationRequest,
          @Req() req: RequestWithUser,
        ) {
          return this.organizationsService.createOrganization(
            req.user.sub,
            createOrganizationDto,
          );
        }
      }
     
     Для забезпечення надійності та безпеки системи критично важливим є етап валідації даних, що надходять від клієнта. Ця логіка інкапсульована в об'єктах передачі даних (DTO), які описують очікувану структуру інформації. Завдяки використанню спеціалізованих декораторів валідації система автоматично перевіряє тип даних, обов’язковість полів та їх відповідність встановленим обмеженням довжини ще до того, як запит потрапить до бізнес-логіки. Такий підхід дозволяє відфільтрувати некоректні запити на ранньому етапі обробки.
     Об'єкт передачі даних (DTO) для створення організації:
     
      export class OrganizationRequest {
        @ApiProperty()
        @IsString()
        @IsNotEmpty()
        @MaxLength(COLUMN_LENGTHS.TITLE)
        title: string;
      
        @ApiProperty({ required: false })
        @IsString()
        @IsOptional()
        @MaxLength(COLUMN_LENGTHS.DESCRIPTION)
        description?: string;
      } 
     2.3.2 Логіка взаємодії серверної частини з БД.
     Безпосередня робота з даними та реалізація бізнес-правил зосереджені у сервісному шарі застосунку. Взаємодія з базою даних здійснюється через ORM TypeORM, що дозволяє маніпулювати записами як об'єктами. Особливу увагу приділено забезпеченню цілісності даних при виконанні складних операцій, які зачіпають декілька пов’язаних сутностей. У наведеному нижче фрагменті коду продемонстровано використання механізму транзакцій. Це гарантує, що створення організації, будівлі, поверху та відповідних зон відбувається атомарно: або всі записи будуть успішно збережені в базі даних, або, у випадку виникнення помилки на будь-якому кроці, жодні зміни не будуть застосовані.
     Сервісний метод створення сутностей із використанням транзакції.
     
      @Injectable()
      export class OrganizationsService {
        constructor(
          private readonly dataSource: DataSource,
        ) {}
      
        async createOrganization(
          organizationAdminId: number,
          createOrganizationDto: OrganizationRequest,
        ): Promise<CreateOrganizationResponse> {
          const organizationAdmin = await this.validateOrganizationAdmin(organizationAdminId);
      
          return await this.dataSource.transaction(async (manager) => {
            const organization = manager.create(Organization, {
              ...createOrganizationDto,
              organization_admin: organizationAdmin,
            });
            await manager.save(organization);
      
            const building = manager.create(Building, {
              address: createOrganizationDto.description,
              organization,
            });
            await manager.save(building);
      
            const floor = manager.create(Floor, {
              building,
            });
            await manager.save(floor);
      
            const zone = manager.create(Zone, {
              floor,
              building,
            });
            await manager.save(zone);
      
            const door = manager.create(Door, {
              zone_to: zone,
              is_entrance: true,
              entrance_door_side: DoorSide.BOTTOM,
              floor: floor,
            });
            await manager.save(door);
      
            return OrganizationsMapper.toCreateOrganizationResponse(
              organization,
              building,
              floor,
              zone,
              door,
            );
          });
        }
      }
     2.4 Графічні ілюстрації
     2.4.1 UML діаграма прецедентів для серверної частини
     Для візуалізації функціональних вимог та взаємодії акторів із системою було розроблено діаграму прецедентів. Головними акторами системи виступають "Адміністратор організації", "Глобальний адміністратор", "Співробітник", "Адміністратор тегів", а також зовнішня апаратна сутність — "RFID зчитувач".
     Діаграма демонструє розмежування прав доступу та сценаріїв використання. Адміністратор організації має найширший спектр повноважень, включаючи створення організацій, керування будівлями, зонами, співробітниками та призначення посад. Сценарій "Авторизація" (Authorization) є базовим та включається у більшість захищених операцій. Окрему увагу приділено взаємодії з апаратним забезпеченням: актор "RFID зчитувач " ініціює прецедент "Виявлення RFID-мітки", що запускає ланцюжок перевірок доступу на сервері. Також передбачено сценарії для перегляду статистики, керування обліковими записами та обробки подій сканування.
 
Рисунок 2.11 – UML діаграма прецедентів для серверної частини
     2.4.2 ER діаграма
     Логічна структура даних системи спроєктована з урахуванням ієрархічної залежності об'єктів фізичного світу. Центральною сутністю є Organization (Організація), яка виступає кореневим елементом для більшості даних. ER-діаграма відображає зв'язки типу "один-до-багатьох", що дозволяють побудувати чітку структуру приміщень: одна Організація містить багато Будівель (Building), кожна Будівля поділяється на Поверхи (Floor), які, у свою чергу, складаються із Зон (Zone).
     Ключовим елементом логіки контролю доступу є сутність Door (Двері), яка пов'язує дві зони (звідки та куди здійснюється перехід) та керується конкретним RFID-зчитувачем. Сутність Employee (Співробітник) має зв'язок із таблицею Position (Посада) та RFID tag (Мітка), що дозволяє гнучко налаштовувати права доступу персоналу. Така нормалізована структура забезпечує відсутність дублювання даних та гарантує логічну цілісність інформаційної системи.
 
Рисунок 2.12 – ER діаграма
     2.4.3 Діаграма структури бази даних
     Фізична реалізація моделі даних виконана в реляційній СКБД PostgreSQL. Діаграма структури бази даних деталізує таблиці, типи даних полів, первинні (PK) та зовнішні (FK) ключі. Усі таблиці містять службові поля created_at для аудиту часу створення записів. Для забезпечення безпеки, чутливі дані адміністраторів та співробітників зберігаються у відповідних таблицях organization_admin, global_admin та employee.
     Особливістю схеми є таблиця scan_event, яка слугує журналом подій. Вона фіксує кожен факт зчитування мітки, зберігаючи посилання на rfid_reader_id та rfid_tag_id, що дозволяє в подальшому будувати аналітичні звіти щодо переміщення персоналу. Правила доступу відокремлені у таблиці zone_access_rule та zone_rule_assignment, що дозволяє динамічно змінювати політики безпеки без необхідності модифікації структури самої бази даних. Цілісність посилань забезпечується на рівні бази даних через Constraints, що унеможливлює появу "сирітських" записів при видаленні батьківських сутностей.

Рисунок 2.13 – Діаграма структури бази даних 

3 ВИСНОВКИ
     У ході виконання лабораторної роботи було спроєктовано та реалізовано серверну частину програмної системи InZone, яка включає розробку реляційної бази даних та прикладного програмного інтерфейсу (API). У процесі виконання роботи було поглиблено розуміння принципів побудови модульної архітектури бекенду, організації взаємодії з клієнтськими застосунками та інтеграції з IoT-пристроями.
     Було опрацьовано етапи проєктування структури даних, зокрема створено UML-діаграму прецедентів для серверної частини, ER-діаграму та діаграму структури бази даних. Це дозволило сформувати оптимізовану логічну та фізичну модель бази даних у PostgreSQL, яка враховує ієрархічні зв'язки між організаціями, будівлями та зонами, а також забезпечує надійне зберігання інформації про співробітників та події доступу.
     Особливу увагу приділено програмній реалізації бізнес-логіки з використанням фреймворку NestJS та ORM-бібліотеки TypeORM. Було набуто практичні навички роботи з механізмом міграцій, використання транзакцій для забезпечення атомарності складних операцій, а також валідації вхідних даних (DTO). Також було реалізовано специфікацію REST API та інтегровано інструментарій Swagger для автоматичної генерації інтерактивної документації за стандартом OpenAPI 3.0.
     Було проаналізовано та впроваджено сучасні підходи до безпеки та комунікації, зокрема систему автентифікації на базі JWT, ролеву модель доступу (RBAC) та взаємодію з RFID-зчитувачами через протокол MQTT (брокер EMQX). Використання технології контейнеризації Docker дозволило налаштувати ізольоване середовище для стабільної роботи всіх сервісів системи.
     Таким чином, у результаті виконання лабораторної роботи було сформовано цілісне уявлення про повний цикл розробки серверної частини: від проєктування схеми даних до реалізації захищеного API та інтеграції з апаратною інфраструктурою.
     Посилання на GitHub: https://github.com/InZoneProject/backend
		 2



